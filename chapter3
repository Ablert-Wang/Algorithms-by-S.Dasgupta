3.1
A->B is a tree edge
B->C is a tree edge
C->F is a tree edge
F->E is a tree edge
F->I is a tree edge
E->B is a back edge
E->A is a back edge
prev = [0, 1, 2, -1, 4, 3, -1, -1, 6]
post = 11, 10, 9, -1, 5, 8, -1, -1, 7]

D->G is a tree edge
G->H is a tree edge
H->D is a back edge
prev = [0, 1, 2, 12, 4, 3, 13, 14, 6]
post = [11, 10, 9, 17, 5, 8, 16, 15, 7] 

3.2
(a)
A->B is a tree edge
B->C is a tree edge
C->D is a tree edge
D->B is a back edge
D->H is a tree edge
H->G is a tree edge
G->F is a tree edge
F->E is a tree edge
A->F is a forward edge
B->E is a forward edge
E->G is a backward edge
E->D is a backward edge
prev = [0, 1, 2, 3, 7, 6, 5, 4]
post = [15, 14, 13, 12, 8, 9, 10, 11]
(b) 
Do I really want to do this? I think I grasp this point already

3.3
(a) Not sure what the dfs based topo algo is .Oh got it, sort in decreasing
    order of post values.
    B,A,C,E,D,F,H,G... Yay!
    prev = [0, 14, 1, 2, 10, 3, 4, 6, -1]
    post = [13, 15, 12, 9, 11, 8, 5, 7, -1]

(b) A and B are the sources, G and H are the sinks
(c) (A/B)->C->(D/E)->F->(G/H)
(d) it has 8 possible topological orderings

3.4

3.5
def reverseGraph(G, u):
    for v in G[u]:
        if u not in RG[v]:  # don't think this is linear time, if I have to search
            RG[v].append(u)  # make the parent the child in the reversed Graph
            reverseGraph(G, v)
I can also do this by extracting all the edges,
reversing them and constructing an adjacency representation again.

3.6
(a) every edge represents an addition to the
    in and out degree
(b) it is obvious? even+ odd*even = even
(c)

3.7
(a) do a dfs but mark each node as belonging to v1 or v2
    def dfs(G,u,c):
        if colour[u]== -1:  # not coloured
            colour[u] = c
        elif colour[u]!=c:
            return False # graph is not bipartite  
        for v in G[u]:
            ans&=dfs(G,v, not(color))
        return ans

(b) if it has a cycle of odd length.. then 0-1-0-1
(c) 3 colours?

3.8
10,7,4 - exactly 2 pints in 7 or 4 container. 10 - 4 put in the 7 pint container. 
then fill the 4 pint container from the 6 pints in the 7 container.
2 pints in the 7 container. 
(a) if there is a path that has a distance of exactly 2?
(b)
(c)

3.9
visited[u]=True
ans = 0
for v in G[u]:
    if not visited[v]:
        dfs(G, v)
        ans+=len(G[v])
twodegree[u] = ans

3.10
def dfs(G,u):
    visited = [False]*n
    stack = [u]
    clock = 0
    prev[u] = clock
    clock+=1
    while stack:
        u = stack.pop(-1)
        visited[u] = True
        post[u] = clock
        clock+=1
        for v in G[u]:
            if not visited[v]:
                stack.append(v)
                prev[v]= clock
                clock+=1

3.11
Try to find a path from v to u given edge (u,v) . do a dfs
