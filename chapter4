4.1
(a) [inf, 0, inf, inf, inf, inf, inf, inf, inf]
    [inf, 0, 1, inf, inf, 4, 8, inf, inf]
    [inf, 0, 1, 3, inf, 4, 7, 7, inf]
    [inf, 0, 1, 3, 4, 4, 7, 5, inf]
    [inf, 0, 1, 3, 4, 4, 7, 5, 8]
    [inf, 0, 1, 3, 4, 4, 7, 5, 8]
    [inf, 0, 1, 3, 4, 4, 6, 5, 6]
    [inf, 0, 1, 3, 4, 4, 6, 5, 6]
    [inf, 0, 1, 3, 4, 4, 6, 5, 6]
    [inf, 0, 1, 3, 4, 4, 6, 5, 6]
(b) A->B->C->D
    |     |
    E  F<-G->H  

4.2 
BellmanFord on the graph at each iteration
0 [0, inf, inf, inf, inf, inf, inf, inf, inf, inf]
1 [0, 7, 6, inf, inf, 6, 5, inf, 9, inf]
2 [0, 7, 6, 5, 7, 6, 4, 4, 2, 3]
3 [0, 7, 6, 5, 7, 6, 4, 3, 2, 2]
4 [0, 7, 6, 5, 7, 6, 4, 3, 2, 2]
5 [0, 7, 6, 5, 7, 6, 4, 3, 2, 2]
6 [0, 7, 6, 5, 7, 6, 4, 3, 2, 2]
7 [0, 7, 6, 5, 7, 6, 4, 3, 2, 2]
8 [0, 7, 6, 5, 7, 6, 4, 3, 2, 2]
9 [0, 7, 6, 5, 7, 6, 4, 3, 2, 2]

4.3 Dfs starting from every node. Count the number of edges it has passed
    till it reached the original node again, if it does.

4.4 Length of the shortest cycle
    when v and w are cross edges? yup.. so you need to do level[v]+level[w]+1 to get a shortest cycle.
    hm.. no cross edges in undirected graphs. if level is the shortest distance to the root then we
    have a problem.

4.5 
4.6 Assume it is not a tree.

4.7 

4.8 It is not a valid method since each path gets increased by a different
    number depending on the number of edges it has.

4.9 Yes, it can. supoose for one of its neighboring edges, it is s->t is 2

